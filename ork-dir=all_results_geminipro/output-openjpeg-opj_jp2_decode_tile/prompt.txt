<system>
You are a security testing engineer who wants to write a C++ program to execute all lines in a given function by defining and initializing its parameters in a suitable way before fuzzing the function through <code>LLVMFuzzerTestOneInput</code>.

Carefully study the function signature and its parameters, then follow the example problems and solutions to answer the final problem. YOU MUST call the function to fuzz in the solution.

Try as many variations of these inputs as possible. Do not use a random number generator such as <code>rand()</code>.

Use <code>FuzzedDataProvider</code> to generate these inputs. You MUST declare it in <code>LLVMFuzzerTestOneInput</code>, like this:
<code>
FuzzedDataProvider stream(data, size);
</code>

Include <code>#include <fuzzer/FuzzedDataProvider.h></code> in the solution.

This code shows example of using it:
<code>
// Extract integral values
int int_arg = stream.ConsumeIntegral<int>();
int int_arg_in_range = stream.ConsumeIntegralInRange(-100, 100);
bool bool_arg = stream.ConsumeBool();

// Extract floating point values
float probability = stream.ConsumeProbability();
double double_arg = stream.ConsumeFloatingPoint<double>();
double double_arg_in_range = stream.ConsumeFloatingPointInRange(-1.0, 1.0);

// Extract value from predefined set, such as enum or array
EnumType enum = stream.ConsumeEnum<EnumType>();
int valid_values = stream.PickValueInArray({FLAG_1, FLAG_2, FLAG_3});

// Extract an array of bytes as a vector. You MUST call <code>.data()</code> to use result as pointer.
std::vector<uint8_t> bytes = stream.ConsumeBytes<uint8_t>(stream.ConsumeIntegralInRange(0, max_size));
void *data_ptr = bytes.data();
std::vector<uint8_t> bytes2 = stream.ConsumeBytes<uint8_t>(requested_size);
void *data2_ptr = bytes2.data();

// Extract a string. You MUST use <code>.c_str()</code> to use result as pointer
std::string str = stream.ConsumeBytesAsString(stream.ConsumeIntegralInRange(0, max_size));
char *ptr = str.c_str();
std::string str2 = stream.ConsumeBytesAsString(requested_size);
char *ptr2 = str2.c_str();
std::string str3 = stream.ConsumeRandomLengthString();
char *ptr3 = str3.c_str();

// Extract to user defined object
struct_type_t obj;
size_t consumed = stream.ConsumeData(&obj, sizeof(obj));
</code>

There MUST be AT MOST ONE call to <code>ConsumeRemainingBytes</code> to consume remaining input!
<code>
FuzzedDataProvider stream(data, size);

std::vector<uint8_t> bytes3 = stream.ConsumeRemainingBytes();
void *data3_ptr = bytes3.data();
</code>

All variables used MUST be declared and initialized. Carefully make sure that the variable and argument types in your code match and compiles successfully. Add type casts to make types match.

Do not create new variables with the same names as existing variables.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  void* data = Foo();
}
</code>

EXTREMELY IMPORTANT: If you write code using <code>goto</code>, you MUST MUST also declare all variables BEFORE the <code>goto</code>. Never introduce new variables after the <code>goto</code>.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  if (!some_function()) goto EXIT;
  Foo b = target_function(data, size);
  int c = another_func();
EXIT:
  return 0;
}
</code>

CORRECT:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  Foo b;
  int c;

  if (!some_function()) goto EXIT;
  b = target_function(data, size);
  c = another_func()
EXIT:
  return 0;
}
</code>

If an example provided for the same library includes a unique header file, then it must be included in the solution as well.
</system>

<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
void opj_image_destroy(struct opj_image * )
</function header>
</task>

<solution>

#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include "openjpeg.h"

extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv);
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len);

typedef struct {
  const uint8_t *pabyData;
  size_t nCurPos;
  size_t nLength;
} MemFile;

static void ErrorCallback(const char *msg, void *) {
  (void)msg;
  // fprintf(stderr, "%s\n", msg);
}

static void WarningCallback(const char *, void *) {}

static void InfoCallback(const char *, void *) {}

static OPJ_SIZE_T ReadCallback(void *pBuffer, OPJ_SIZE_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  // printf("want to read %d bytes at %d\n", (int)memFile->nCurPos, (int)nBytes);
  if (memFile->nCurPos >= memFile->nLength) {
    return -1;
  }
  if (memFile->nCurPos + nBytes >= memFile->nLength) {
    size_t nToRead = memFile->nLength - memFile->nCurPos;
    memcpy(pBuffer, memFile->pabyData + memFile->nCurPos, nToRead);
    memFile->nCurPos = memFile->nLength;
    return nToRead;
  }
  if (nBytes == 0) {
    return -1;
  }
  memcpy(pBuffer, memFile->pabyData + memFile->nCurPos, nBytes);
  memFile->nCurPos += nBytes;
  return nBytes;
}

static OPJ_BOOL SeekCallback(OPJ_OFF_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  // printf("seek to %d\n", (int)nBytes);
  memFile->nCurPos = nBytes;
  return OPJ_TRUE;
}

static OPJ_OFF_T SkipCallback(OPJ_OFF_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  memFile->nCurPos += nBytes;
  return nBytes;
}

int LLVMFuzzerInitialize(int * /*argc*/, char ***argv) { return 0; }

static const unsigned char jpc_header[] = {0xff, 0x4f};
static const unsigned char jp2_box_jp[] = {0x6a, 0x50, 0x20, 0x20}; /* 'jP  ' */

int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {

  OPJ_CODEC_FORMAT eCodecFormat;
  if (len >= 4 + sizeof(jp2_box_jp) && memcmp(buf + 4, jp2_box_jp, sizeof(jp2_box_jp)) == 0) {
    eCodecFormat = OPJ_CODEC_JP2;
  } else {
    return 0;
  }

  opj_codec_t *pCodec = opj_create_decompress(eCodecFormat);
  opj_set_info_handler(pCodec, InfoCallback, NULL);
  opj_set_warning_handler(pCodec, WarningCallback, NULL);
  opj_set_error_handler(pCodec, ErrorCallback, NULL);

  opj_dparameters_t parameters;
  opj_set_default_decoder_parameters(&parameters);

  opj_setup_decoder(pCodec, &parameters);

  opj_stream_t *pStream = opj_stream_create(1024, OPJ_TRUE);
  MemFile memFile;
  memFile.pabyData = buf;
  memFile.nLength = len;
  memFile.nCurPos = 0;
  opj_stream_set_user_data_length(pStream, len);
  opj_stream_set_read_function(pStream, ReadCallback);
  opj_stream_set_seek_function(pStream, SeekCallback);
  opj_stream_set_skip_function(pStream, SkipCallback);
  opj_stream_set_user_data(pStream, &memFile, NULL);

  opj_image_t *psImage = NULL;
  if (!opj_read_header(pStream, pCodec, &psImage)) {
    opj_destroy_codec(pCodec);
    opj_stream_destroy(pStream);
    opj_image_destroy(psImage);
    return 0;
  }

  OPJ_UINT32 width = psImage->x1 - psImage->x0;
  OPJ_UINT32 height = psImage->y1 - psImage->y0;

#if 0
    // Reject too big images since that will require allocating a lot of
    // memory
    if (width != 0 && psImage->numcomps != 0 &&
            (width > INT_MAX / psImage->numcomps ||
             height > INT_MAX / (width * psImage->numcomps * sizeof(OPJ_UINT32)))) {
        opj_stream_destroy(pStream);
        opj_destroy_codec(pCodec);
        opj_image_destroy(psImage);

        return 0;
    }

    // Also reject too big tiles.
    // TODO: remove this limitation when subtile decoding no longer imply
    // allocation memory for whole tile
    opj_codestream_info_v2_t* pCodeStreamInfo = opj_get_cstr_info(pCodec);
    OPJ_UINT32 nTileW, nTileH;
    nTileW = pCodeStreamInfo->tdx;
    nTileH = pCodeStreamInfo->tdy;
    opj_destroy_cstr_info(&pCodeStreamInfo);
    if (nTileW > 2048 || nTileH > 2048) {
        opj_stream_destroy(pStream);
        opj_destroy_codec(pCodec);
        opj_image_destroy(psImage);

        return 0;
    }
#endif

  OPJ_UINT32 width_to_read = width;
  if (width_to_read > 1024) {
    width_to_read = 1024;
  }
  OPJ_UINT32 height_to_read = height;
  if (height_to_read > 1024) {
    height_to_read = 1024;
  }

  if (opj_set_decode_area(pCodec, psImage, psImage->x0, psImage->y0, psImage->x0 + width_to_read, psImage->y0 + height_to_read)) {
    if (opj_decode(pCodec, pStream, psImage)) {
      // printf("success\n");
    }
  }

  opj_end_decompress(pCodec, pStream);
  opj_stream_destroy(pStream);
  opj_destroy_codec(pCodec);
  opj_image_destroy(psImage);

  return 0;
}

</solution>


<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
int opj_jp2_decode_tile(struct opj_jp2 * , int , char * , int , struct opj_stream_private * , struct opj_event_mgr * )
</function header>
</task>
You MUST call <code>
int opj_jp2_decode_tile(struct opj_jp2 * , int , char * , int , struct opj_stream_private * , struct opj_event_mgr * )
</code> in your solution!

<solution>
