Given the following C++ program and its build error message, fix the code to achieve the original functionality.

If a function is missing, fix it by including the related libraries.

If the error contains "undefined reference to", this means one or more of the header <code>#include</code> directives need to be wrapped with <code>extern "C" {}</code> for the object linking to succeed. You must fix this by rewriting the relevant <code>#include</code> and wrapping it with <code>extern "C" {}</code>.

Below is the code needs to be built:
<code>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include "openjpeg.h"

extern "C" int LLVMFuzzerInitialize(int *argc, char ***argv);
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len);

typedef struct {
  const uint8_t *pabyData;
  size_t nCurPos;
  size_t nLength;
} MemFile;

static void ErrorCallback(const char *msg, void *) {
  (void)msg;
  // fprintf(stderr, "%s\n", msg);
}

static void WarningCallback(const char *, void *) {}

static void InfoCallback(const char *, void *) {}

static OPJ_SIZE_T ReadCallback(void *pBuffer, OPJ_SIZE_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  // printf("want to read %d bytes at %d\n", (int)memFile->nCurPos, (int)nBytes);
  if (memFile->nCurPos >= memFile->nLength) {
    return -1;
  }
  if (memFile->nCurPos + nBytes >= memFile->nLength) {
    size_t nToRead = memFile->nLength - memFile->nCurPos;
    memcpy(pBuffer, memFile->pabyData + memFile->nCurPos, nToRead);
    memFile->nCurPos = memFile->nLength;
    return nToRead;
  }
  if (nBytes == 0) {
    return -1;
  }
  memcpy(pBuffer, memFile->pabyData + memFile->nCurPos, nBytes);
  memFile->nCurPos += nBytes;
  return nBytes;
}

static OPJ_BOOL SeekCallback(OPJ_OFF_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  // printf("seek to %d\n", (int)nBytes);
  memFile->nCurPos = nBytes;
  return OPJ_TRUE;
}

static OPJ_OFF_T SkipCallback(OPJ_OFF_T nBytes, void *pUserData) {
  MemFile *memFile = (MemFile *)pUserData;
  memFile->nCurPos += nBytes;
  return nBytes;
}

int LLVMFuzzerInitialize(int *argc, char ***argv) { return 0; }

static const unsigned char jpc_header[] = {0xff, 0x4f};
static const unsigned char jp2_box_jp[] = {0x6a, 0x50, 0x20, 0x20}; /* 'jP  ' */

int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {

  OPJ_CODEC_FORMAT eCodecFormat;
  if (len >= 4 + sizeof(jp2_box_jp) && memcmp(buf + 4, jp2_box_jp, sizeof(jp2_box_jp)) == 0) {
    eCodecFormat = OPJ_CODEC_JP2;
  } else {
    return 0;
  }

  opj_codec_t *pCodec = opj_create_decompress(eCodecFormat);
  if (!pCodec) {
    return 0;
  }
  opj_set_info_handler(pCodec, InfoCallback, NULL);
  opj_set_warning_handler(pCodec, WarningCallback, NULL);
  opj_set_error_handler(pCodec, ErrorCallback, NULL);

  opj_dparameters_t parameters;
  opj_set_default_decoder_parameters(&parameters);

  opj_setup_decoder(pCodec, &parameters);

  opj_stream_t *pStream = opj_stream_create(1024, OPJ_TRUE);
  if (!pStream) {
    opj_destroy_codec(pCodec);
    return 0;
  }
  MemFile memFile;
  memFile.pabyData = buf;
  memFile.nLength = len;
  memFile.nCurPos = 0;
  opj_stream_set_user_data_length(pStream, len);
  opj_stream_set_read_function(pStream, ReadCallback);
  opj_stream_set_seek_function(pStream, SeekCallback);
  opj_stream_set_skip_function(pStream, SkipCallback);
  opj_stream_set_user_data(pStream, &memFile, NULL);

  opj_image_t *psImage = NULL;
  if (!opj_read_header(pStream, pCodec, &psImage)) {
    opj_destroy_codec(pCodec);
    opj_stream_destroy(pStream);
    opj_image_destroy(psImage);
    return 0;
  }

  OPJ_UINT32 width = psImage->x1 - psImage->x0;
  OPJ_UINT32 height = psImage->y1 - psImage->y0;

  OPJ_UINT32 tile_width = psImage->tile_width;
  OPJ_UINT32 tile_height = psImage->tile_height;

  OPJ_UINT32 tile_index = 0;
  OPJ_UINT32 tile_x = 0;
  OPJ_UINT32 tile_y = 0;

  opj_stream_private_t *stream_private = opj_stream_private_create(pStream, 0);
  opj_event_mgr_t *event_mgr = opj_event_manager_create();

  while (tile_index < psImage->numtiles) {
    opj_jp2_decode_tile(pCodec, tile_index, NULL, 0, stream_private, event_mgr);
    tile_x += tile_width;
    if (tile_x >= width) {
      tile_x = 0;
      tile_y += tile_height;
    }
    tile_index++;
  }

  opj_event_manager_destroy(event_mgr);
  opj_stream_private_destroy(stream_private);
  opj_end_decompress(pCodec, pStream);
  opj_stream_destroy(pStream);
  opj_destroy_codec(pCodec);
  opj_image_destroy(psImage);

  return 0;
}
</code>

The code has the following build issues:
<error>

</error>

Fix code:
1. Consider the possible solution for the issues listed above.
2. Apply the solutions to the original code.
It's important to show the complete code, not only the fixed line.
<solution>
