<system>
You are a security testing engineer who wants to write a C++ program to execute all lines in a given function by defining and initializing its parameters in a suitable way before fuzzing the function through <code>LLVMFuzzerTestOneInput</code>.

Carefully study the function signature and its parameters, then follow the example problems and solutions to answer the final problem. YOU MUST call the function to fuzz in the solution.

Try as many variations of these inputs as possible. Do not use a random number generator such as <code>rand()</code>.

Use <code>FuzzedDataProvider</code> to generate these inputs. You MUST declare it in <code>LLVMFuzzerTestOneInput</code>, like this:
<code>
FuzzedDataProvider stream(data, size);
</code>

Include <code>#include <fuzzer/FuzzedDataProvider.h></code> in the solution.

This code shows example of using it:
<code>
// Extract integral values
int int_arg = stream.ConsumeIntegral<int>();
int int_arg_in_range = stream.ConsumeIntegralInRange(-100, 100);
bool bool_arg = stream.ConsumeBool();

// Extract floating point values
float probability = stream.ConsumeProbability();
double double_arg = stream.ConsumeFloatingPoint<double>();
double double_arg_in_range = stream.ConsumeFloatingPointInRange(-1.0, 1.0);

// Extract value from predefined set, such as enum or array
EnumType enum = stream.ConsumeEnum<EnumType>();
int valid_values = stream.PickValueInArray({FLAG_1, FLAG_2, FLAG_3});

// Extract an array of bytes as a vector. You MUST call <code>.data()</code> to use result as pointer.
std::vector<uint8_t> bytes = stream.ConsumeBytes<uint8_t>(stream.ConsumeIntegralInRange(0, max_size));
void *data_ptr = bytes.data();
std::vector<uint8_t> bytes2 = stream.ConsumeBytes<uint8_t>(requested_size);
void *data2_ptr = bytes2.data();

// Extract a string. You MUST use <code>.c_str()</code> to use result as pointer
std::string str = stream.ConsumeBytesAsString(stream.ConsumeIntegralInRange(0, max_size));
char *ptr = str.c_str();
std::string str2 = stream.ConsumeBytesAsString(requested_size);
char *ptr2 = str2.c_str();
std::string str3 = stream.ConsumeRandomLengthString();
char *ptr3 = str3.c_str();

// Extract to user defined object
struct_type_t obj;
size_t consumed = stream.ConsumeData(&obj, sizeof(obj));
</code>

There MUST be AT MOST ONE call to <code>ConsumeRemainingBytes</code> to consume remaining input!
<code>
FuzzedDataProvider stream(data, size);

std::vector<uint8_t> bytes3 = stream.ConsumeRemainingBytes();
void *data3_ptr = bytes3.data();
</code>

All variables used MUST be declared and initialized. Carefully make sure that the variable and argument types in your code match and compiles successfully. Add type casts to make types match.

Do not create new variables with the same names as existing variables.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  void* data = Foo();
}
</code>

EXTREMELY IMPORTANT: If you write code using <code>goto</code>, you MUST MUST also declare all variables BEFORE the <code>goto</code>. Never introduce new variables after the <code>goto</code>.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  if (!some_function()) goto EXIT;
  Foo b = target_function(data, size);
  int c = another_func();
EXIT:
  return 0;
}
</code>

CORRECT:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  Foo b;
  int c;

  if (!some_function()) goto EXIT;
  b = target_function(data, size);
  c = another_func()
EXIT:
  return 0;
}
</code>

If an example provided for the same library includes a unique header file, then it must be included in the solution as well.
</system>

<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
int ly_ctx_new(char * search_dir, short options, struct ly_ctx ** new_ctx)
</function header>
</task>

<solution>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

#include "libyang.h"

int LLVMFuzzerTestOneInput(uint8_t const *buf, size_t len) {
  struct ly_ctx *ctx = NULL;
  static bool log = false;
  const char *schema_a = "module defs {namespace urn:tests:defs;prefix d;yang-version 1.1;"
                         "identity crypto-alg; identity interface-type; identity ethernet {base interface-type;}"
                         "identity fast-ethernet {base ethernet;}}";
  const char *schema_b = "module types {namespace urn:tests:types;prefix t;yang-version 1.1; import defs {prefix defs;}"
                         "feature f; identity gigabit-ethernet { base defs:ethernet;}"
                         "container cont {leaf leaftarget {type empty;}"
                         "list listtarget {key id; max-elements 5;leaf id {type uint8;} leaf value {type string;}}"
                         "leaf-list leaflisttarget {type uint8; max-elements 5;}}"
                         "list list {key id; leaf id {type string;} leaf value {type string;} leaf-list targets {type string;}}"
                         "list list2 {key \"id value\"; leaf id {type string;} leaf value {type string;}}"
                         "list list_inst {key id; leaf id {type instance-identifier {require-instance true;}} leaf value {type string;}}"
                         "list list_ident {key id; leaf id {type identityref {base defs:interface-type;}} leaf value {type string;}}"
                         "leaf-list leaflisttarget {type string;}"
                         "leaf binary {type binary {length 5 {error-message \"This base64 value must be of length 5.\";}}}"
                         "leaf binary-norestr {type binary;}"
                         "leaf int8 {type int8 {range 10..20;}}"
                         "leaf uint8 {type uint8 {range 150..200;}}"
                         "leaf int16 {type int16 {range -20..-10;}}"
                         "leaf uint16 {type uint16 {range 150..200;}}"
                         "leaf int32 {type int32;}"
                         "leaf uint32 {type uint32;}"
                         "leaf int64 {type int64;}"
                         "leaf uint64 {type uint64;}"
                         "leaf bits {type bits {bit zero; bit one {if-feature f;} bit two;}}"
                         "leaf enums {type enumeration {enum white; enum yellow {if-feature f;}}}"
                         "leaf dec64 {type decimal64 {fraction-digits 1; range 1.5..10;}}"
                         "leaf dec64-norestr {type decimal64 {fraction-digits 18;}}"
                         "leaf str {type string {length 8..10; pattern '[a-z ]*';}}"
                         "leaf str-norestr {type string;}"
                         "leaf str-utf8 {type string{length 2..5; pattern 'â‚¬*';}}"
                         "leaf bool {type boolean;}"
                         "leaf empty {type empty;}"
                         "leaf ident {type identityref {base defs:interface-type;}}"
                         "leaf inst {type instance-identifier {require-instance true;}}"
                         "leaf inst-noreq {type instance-identifier {require-instance false;}}"
                         "leaf lref {type leafref {path /leaflisttarget; require-instance true;}}"
                         "leaf lref2 {type leafref {path \"../list[id = current()/../str-norestr]/targets\"; require-instance true;}}"
                         "leaf un1 {type union {"
                         "type leafref {path /int8; require-instance true;}"
                         "type union { type identityref {base defs:interface-type;} type instance-identifier {require-instance true;} }"
                         "type string {length 1..20;}}}}";
  char *data = NULL;
  struct lyd_node *tree = NULL;
  LY_ERR err;

  if (!log) {
    ly_log_options(0);
    log = true;
  }

  err = ly_ctx_new(NULL, 0, &ctx);
  if (err != LY_SUCCESS) {
    fprintf(stderr, "Failed to create context\n");
    exit(EXIT_FAILURE);
  }

  lys_parse_mem(ctx, schema_a, LYS_IN_YANG, NULL);
  lys_parse_mem(ctx, schema_b, LYS_IN_YANG, NULL);

  data = malloc(len + 1);
  if (data == NULL) {
    return 0;
  }
  memcpy(data, buf, len);
  data[len] = 0;

  lyd_parse_data_mem(ctx, data, LYD_JSON, 0, LYD_VALIDATE_PRESENT, &tree);
  lyd_free_all(tree);
  ly_ctx_destroy(ctx);

  free(data);

  return 0;
}

</solution>


<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
int structure_parse(struct lysp_ctx * pctx, struct lysp_ext_instance * ext)
</function header>
</task>
You MUST call <code>
int structure_parse(struct lysp_ctx * pctx, struct lysp_ext_instance * ext)
</code> in your solution!

<solution>
