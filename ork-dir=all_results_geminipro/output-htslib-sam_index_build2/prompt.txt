<system>
You are a security testing engineer who wants to write a C++ program to execute all lines in a given function by defining and initializing its parameters in a suitable way before fuzzing the function through <code>LLVMFuzzerTestOneInput</code>.

Carefully study the function signature and its parameters, then follow the example problems and solutions to answer the final problem. YOU MUST call the function to fuzz in the solution.

Try as many variations of these inputs as possible. Do not use a random number generator such as <code>rand()</code>.

Use <code>FuzzedDataProvider</code> to generate these inputs. You MUST declare it in <code>LLVMFuzzerTestOneInput</code>, like this:
<code>
FuzzedDataProvider stream(data, size);
</code>

Include <code>#include <fuzzer/FuzzedDataProvider.h></code> in the solution.

This code shows example of using it:
<code>
// Extract integral values
int int_arg = stream.ConsumeIntegral<int>();
int int_arg_in_range = stream.ConsumeIntegralInRange(-100, 100);
bool bool_arg = stream.ConsumeBool();

// Extract floating point values
float probability = stream.ConsumeProbability();
double double_arg = stream.ConsumeFloatingPoint<double>();
double double_arg_in_range = stream.ConsumeFloatingPointInRange(-1.0, 1.0);

// Extract value from predefined set, such as enum or array
EnumType enum = stream.ConsumeEnum<EnumType>();
int valid_values = stream.PickValueInArray({FLAG_1, FLAG_2, FLAG_3});

// Extract an array of bytes as a vector. You MUST call <code>.data()</code> to use result as pointer.
std::vector<uint8_t> bytes = stream.ConsumeBytes<uint8_t>(stream.ConsumeIntegralInRange(0, max_size));
void *data_ptr = bytes.data();
std::vector<uint8_t> bytes2 = stream.ConsumeBytes<uint8_t>(requested_size);
void *data2_ptr = bytes2.data();

// Extract a string. You MUST use <code>.c_str()</code> to use result as pointer
std::string str = stream.ConsumeBytesAsString(stream.ConsumeIntegralInRange(0, max_size));
char *ptr = str.c_str();
std::string str2 = stream.ConsumeBytesAsString(requested_size);
char *ptr2 = str2.c_str();
std::string str3 = stream.ConsumeRandomLengthString();
char *ptr3 = str3.c_str();

// Extract to user defined object
struct_type_t obj;
size_t consumed = stream.ConsumeData(&obj, sizeof(obj));
</code>

There MUST be AT MOST ONE call to <code>ConsumeRemainingBytes</code> to consume remaining input!
<code>
FuzzedDataProvider stream(data, size);

std::vector<uint8_t> bytes3 = stream.ConsumeRemainingBytes();
void *data3_ptr = bytes3.data();
</code>

All variables used MUST be declared and initialized. Carefully make sure that the variable and argument types in your code match and compiles successfully. Add type casts to make types match.

Do not create new variables with the same names as existing variables.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  void* data = Foo();
}
</code>

EXTREMELY IMPORTANT: If you write code using <code>goto</code>, you MUST MUST also declare all variables BEFORE the <code>goto</code>. Never introduce new variables after the <code>goto</code>.
WRONG:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  if (!some_function()) goto EXIT;
  Foo b = target_function(data, size);
  int c = another_func();
EXIT:
  return 0;
}
</code>

CORRECT:
<code>
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  int a = bar();
  Foo b;
  int c;

  if (!some_function()) goto EXIT;
  b = target_function(data, size);
  c = another_func()
EXIT:
  return 0;
}
</code>

If an example provided for the same library includes a unique header file, then it must be included in the solution as well.
</system>

<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
struct htsFile * hts_hopen(struct hFILE * hfile, char * fn, char * mode)
</function header>
</task>

<solution>

#include <config.h>

#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "../../htslib/hfile.h"
#include "../../htslib/hts.h"
#include "../../htslib/sam.h"
#include "../../htslib/vcf.h"

static void hts_close_or_abort(htsFile *file) {
  if (hts_close(file) != 0) {
    abort();
  }
}

static void view_sam(const uint8_t *data, size_t size, char *mode, int close_abort) {
  uint8_t *copy = malloc(size);
  if (copy == NULL) {
    abort();
  }
  memcpy(copy, data, size);

  hFILE *memfile = hopen("mem:", "rb:", copy, size);
  if (memfile == NULL) {
    free(copy);
    return;
  }

  htsFile *in = hts_hopen(memfile, "data", "rb");
  if (in == NULL) {
    if (hclose(memfile) != 0)
      abort();
    return;
  }

  samFile *out = sam_open("/dev/null", mode);
  if (!out)
    abort();

#ifdef FUZZ_FAI
  // Not critical if this doesn't work, but can test more if
  // we're in the right location.
  //
  // We can't rely on what the pwd is for the OSS-fuzz so we don't enable
  // this by default.
  if (hts_set_fai_filename(out, "../c2.fa") < 0) {
    static int warned = 0;
    if (!warned) {
      warned = 1;
      fprintf(stderr, "Warning couldn't find the c2.fa file\n");
    }
  }
#endif

  sam_hdr_t *hdr = sam_hdr_read(in);
  if (hdr == NULL) {
    if (close_abort)
      hts_close_or_abort(out);
    else
      hts_close(out);
    hts_close(in);
    return;
  }

  // This will force the header to be parsed.
  (void)sam_hdr_count_lines(hdr, "SQ");

  if (sam_hdr_write(out, hdr) != 0)
    goto err;

  bam1_t *b = bam_init1();
  if (b == NULL)
    goto err;

  while (sam_read1(in, hdr, b) >= 0) {
    if (sam_write1(out, hdr, b) < 0)
      break;
  }
  bam_destroy1(b);

err:
  sam_hdr_destroy(hdr);
  if (close_abort)
    hts_close_or_abort(out);
  else
    hts_close(out);
  hts_close(in);
}

static void view_vcf(const uint8_t *data, size_t size, char *mode) {
  uint8_t *copy = malloc(size);
  if (copy == NULL) {
    abort();
  }
  memcpy(copy, data, size);

  hFILE *memfile = hopen("mem:", "rb:", copy, size);
  if (memfile == NULL) {
    free(copy);
    return;
  }

  htsFile *in = hts_hopen(memfile, "data", "rb");
  if (in == NULL) {
    if (hclose(memfile) != 0)
      abort();
    return;
  }

  vcfFile *out = vcf_open("/dev/null", mode);
  if (!out)
    abort();

  bcf_hdr_t *hdr = bcf_hdr_read(in);
  if (hdr == NULL) {
    hts_close_or_abort(out);
    hts_close(in);
    return;
  }

  if (bcf_hdr_write(out, hdr) != 0)
    goto err;

  bcf1_t *rec = bcf_init();
  if (rec == NULL)
    goto err;

  while (bcf_read(in, hdr, rec) >= 0) {
    if (bcf_write(out, hdr, rec) < 0)
      break;
  }
  bcf_destroy(rec);

err:
  bcf_hdr_destroy(hdr);
  hts_close_or_abort(out);
  hts_close(in);
}

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  // Only data as a mem file purely for purposes of determining format
  hFILE *memfile;
  uint8_t *copy = malloc(size);
  if (copy == NULL) {
    abort();
  }
  memcpy(copy, data, size);
  // hopen does not take ownership of `copy`, but hts_hopen does.
  memfile = hopen("mem:", "rb:", copy, size);
  if (memfile == NULL) {
    free(copy);
    return 0;
  }

  htsFile *ht_file = hts_hopen(memfile, "data", "rb");
  if (ht_file == NULL) {
    if (hclose(memfile) != 0) {
      abort();
    }
    return 0;
  }
  int ftype = ht_file->format.category;
  hts_close(ht_file);

  // Now repeat a read-write loop multiple times per input, testing
  // encoding in all output formats.
  // (Although we could just ignore ftype and do all 5 for all inputs)
  switch (ftype) {
  case sequence_data:
    view_sam(data, size, "w", 1);  // SAM
    view_sam(data, size, "wb", 1); // BAM
    view_sam(data, size, "wc", 0); // CRAM
    break;
  case variant_data:
    view_vcf(data, size, "w");  // VCF
    view_vcf(data, size, "wb"); // BCF
    break;
  default:
    break;
  }
  return 0;
}

</solution>


<task>
Your goal is to write a fuzzing harness for the provided function header using <code>LLVMFuzzerTestOneInput</code>. It is important that the provided solution compiles and actually calls the function specified by the function header:
<function header>
int sam_index_build2(char * fn, char * fnidx, int min_shift)
</function header>
</task>
You MUST call <code>
int sam_index_build2(char * fn, char * fnidx, int min_shift)
</code> in your solution!

<solution>
