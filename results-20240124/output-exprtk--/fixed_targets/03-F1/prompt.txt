Given the following C++ program and its build error message, fix the code to achieve the original functionality.

If a function is missing, fix it by including the related libraries.

If the error contains "undefined reference to", this means one or more of the header <code>#include</code> directives need to be wrapped with <code>extern "C" {}</code> for the object linking to succeed. You must fix this by rewriting the relevant <code>#include</code> and wrapping it with <code>extern "C" {}</code>.

Below is the code needs to be built:
<code>
 #include <cstdint>
#include <chrono>
#include <string>

#define exprtk_enable_range_runtime_checks
#include "exprtk.hpp"

struct timeout_rtc_handler : public exprtk::loop_runtime_check
{
   timeout_rtc_handler()
   : exprtk::loop_runtime_check()
   {}

   class timeout_exception : public std::runtime_error
   {
   public:
       timeout_exception(const std::string& what = "")
       : std::runtime_error(what)
       {}
   };

   static constexpr std::size_t max_iterations = 5000000;

   using time_point_t = std::chrono::time_point<std::chrono::steady_clock>;

   void set_timeout_time(const time_point_t& timeout_tp)
   {
      timeout_tp_ = timeout_tp;
   }

   bool check() override
   {
      if (++iterations_ >= max_iterations)
      {
         if (std::chrono::steady_clock::now() >= timeout_tp_)
         {
            return false;
         }
         iterations_ = 0;
      }

      return true;
   }

   void handle_runtime_violation(const violation_context& ctx) override
   {
      throw timeout_exception("ExprTk Loop run-time timeout violation.");
   }

   std::size_t iterations_ = 0;
   time_point_t timeout_tp_;
};

template <typename T>
void run(const std::string& expression_string)
{
   typedef exprtk::symbol_table<T>    symbol_table_t;
   typedef exprtk::expression<T>      expression_t;
   typedef exprtk::parser<T>          parser_t;
   typedef exprtk::loop_runtime_check loop_runtime_check_t;

   T x = T(1.2345);
   T y = T(2.2345);
   T z = T(3.2345);
   T w = T(4.2345);

   symbol_table_t symbol_table;
   symbol_table.add_variable("x",x);
   symbol_table.add_variable("y",y);
   symbol_table.add_variable("z",z);
   symbol_table.add_variable("w",w);
   symbol_table.add_constants();

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   timeout_rtc_handler loop_runtime_check;
   loop_runtime_check.loop_set = loop_runtime_check_t::e_all_loops;
   loop_runtime_check.max_loop_iterations = 100000;

   parser_t parser;

   parser.register_loop_runtime_check(loop_runtime_check);

   if (parser.compile(expression_string, expression))
   {
      const std::size_t max_expression_size = 64 * 1024;

      if (expression_string.size() <= max_expression_size)
      {
         const auto max_duration = std::chrono::seconds(25);
         const auto timeout_tp = std::chrono::steady_clock::now() + max_duration;
         loop_runtime_check.set_timeout_time(timeout_tp);

         try
         {
            expression.value();
         }
         catch (std::runtime_error& rte)
         {}

         parser.clear_loop_runtime_check();
      }
   }
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
{
   const std::string expression(reinterpret_cast<const char*>(data), size);

   run<double>(expression);
   run<float> (expression);

   return 0;
}
</code>

The code has the following build issues:
<error>
/src/exprtk_fuzzer.cpp:12:40: error: default initialization of an object of const type 'const exprtk::details::operator_type'
  exprtk::details::operator_type const op;
                                       ^
/src/exprtk_fuzzer.cpp:15:18: error: no matching member function for call to 'allocate_rrr'
  node_allocator.allocate_rrr<exprtk::details::vec_binop_vecvec_node<float, exprtk::details::mul_op<float> >, exprtk::details::operator_type const, exprtk::details::expression_node<float>*, exprtk::details::expression_node<float>*>(nullptr, &op, &left, &right);
  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./exprtk.hpp:16746:66: note: candidate function template not viable: requires 3 arguments, but 4 were provided
         inline expression_node<typename node_type::value_type>* allocate_rrr(T1& t1, T2& t2, T3& t3) const
                                                                 ^
/src/exprtk_fuzzer.cpp:23:59: error: use of class template 'std::allocator' requires template arguments
expression_node<float>* node_allocator::allocate_rrr(std::allocator* alloc, T* op, Left* left, Right* right) const {
                                                          ^
/usr/local/bin/../include/c++/v1/__memory/allocator.h:80:28: note: template is declared here
class _LIBCPP_TEMPLATE_VIS allocator
                           ^
/src/exprtk_fuzzer.cpp:30:6: error: functions that differ only in their return type cannot be overloaded
void LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
~~~~ ^
/src/exprtk_fuzzer.cpp:10:5: note: previous definition is here
int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
~~~ ^
/src/exprtk_fuzzer.cpp:32:40: error: default initialization of an object of const type 'const exprtk::details::operator_type'
  exprtk::details::operator_type const op;
                                       ^
/src/exprtk_fuzzer.cpp:35:18: error: no matching member function for call to 'allocate_rrr'
  node_allocator.allocate_rrr<exprtk::details::vec_binop_vecvec_node<float, exprtk::details::mul_op<float> >, exprtk::details::operator_type const, exprtk::details::expression_node<float>*, exprtk::details::expression_node<float>*>(nullptr, &op, &left, &right);
  ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./exprtk.hpp:16746:66: note: candidate function template not viable: requires 3 arguments, but 4 were provided
         inline expression_node<typename node_type::value_type>* allocate_rrr(T1& t1, T2& t2, T3& t3) const
                                                                 ^
6 errors generated.
</error>

Fix code:
1. Consider the possible solution for the issues listed above.
2. Apply the solutions to the original code.
It's important to show the complete code, not only the fixed line.
<solution>
