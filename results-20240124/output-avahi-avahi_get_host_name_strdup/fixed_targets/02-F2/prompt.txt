Given the following C++ program and its build error message, fix the code to achieve the original functionality.

If a function is missing, fix it by including the related libraries.

If the error contains "undefined reference to", this means one or more of the header <code>#include</code> directives need to be wrapped with <code>extern "C" {}</code> for the object linking to succeed. You must fix this by rewriting the relevant <code>#include</code> and wrapping it with <code>extern "C" {}</code>.

Below is the code needs to be built:
<code>
 The fixed code is as follows:

#include <algorithm>
#include <fuzzer/FuzzedDataProvider.h>

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

#include "avahi-common/defs.h"
#include "avahi-common/domain.h"
#include "avahi-common/malloc.h"
#include "avahi-core/dns.h"
#include "avahi-core/domain-util.h"
#include "avahi-core/log.h"

void log_function(AvahiLogLevel level, const char *txt) {}

void domain_ends_with_mdns_suffix(const char *domain) {
  avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL);
  avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4);
  avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6);
}

bool copy_rrs(AvahiDnsPacket *from, AvahiDnsPacket *to, unsigned idx) {
  for (uint16_t n = avahi_dns_packet_get_field(from, idx); n > 0; n--) {
    AvahiRecord *record;
    int cache_flush = 0;
    uint8_t *res;

    if (!(record = avahi_dns_packet_consume_record(from, &cache_flush)))
      return false;

    avahi_free(avahi_record_to_string(record));

    domain_ends_with_mdns_suffix(record->key->name);

    // This resembles the RR callbacks responsible for browsing services
    if (record->key->type == AVAHI_DNS_TYPE_PTR) {
      char service[AVAHI_LABEL_MAX], type[AVAHI_DOMAIN_NAME_MAX], domain[AVAHI_DOMAIN_NAME_MAX];
      char name[AVAHI_DOMAIN_NAME_MAX];
      int res;

      if (avahi_service_name_split(record->data.ptr.name, service, sizeof(service), type, sizeof(type), domain, sizeof(domain)) >= 0) {
        res = avahi_service_name_join(name, sizeof(name), service, type, domain);
        assert(res >= 0);
      }

      if (avahi_service_name_split(record->data.ptr.name, NULL, 0, type, sizeof(type), domain, sizeof(domain)) >= 0) {
        res = avahi_service_name_join(name, sizeof(name), NULL, type, domain);
        assert(res >= 0);
      }
    }

    res = avahi_dns_packet_append_record(to, record, cache_flush, 0);
    avahi_record_unref(record);
    if (!res)
      return false;
    avahi_dns_packet_inc_field(to, idx);
  }
  return true;
}

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
  AvahiDnsPacket *p1 = NULL, *p2 = NULL;
  char *host_name;

  if (size > AVAHI_DNS_PACKET_SIZE_MAX)
    return 0;

  avahi_set_log_function(log_function);

  if (!(p1 = avahi_dns_packet_new(size + AVAHI_DNS_PACKET_EXTRA_SIZE)))
    goto finish;

  memcpy(AVAHI_DNS_PACKET_DATA(p1), data, size);
  p1->size = size;

  if (avahi_dns_packet_check_valid(p1) < 0)
    goto finish;

  if (!(p2 = avahi_dns_packet_new(size + AVAHI_DNS_PACKET_EXTRA_SIZE)))
    goto finish;

  avahi_dns_packet_set_field(p2, AVAHI_DNS_FIELD_ID, avahi_dns_packet_get_field(p1, AVAHI_DNS_FIELD_ID));

  for (uint16_t n = avahi_dns_packet_get_field(p1, AVAHI_DNS_FIELD_QDCOUNT); n > 0; n--) {
    AvahiKey *key;
    int unicast_response = 0;
    uint8_t *res;

    if (!(key = avahi_dns_packet_consume_key(p1, &unicast_response)))
      goto finish;

    avahi_free(avahi_key_to_string(key));

    domain_ends_with_mdns_suffix(key->name);

    res = avahi_dns_packet_append_key(p2, key, unicast_response);
    avahi_key_unref(key);
    if (!res)
      goto finish;
    avahi_dns_packet_inc_field(p2, AVAHI_DNS_FIELD_QDCOUNT);
  }

  if (!copy_rrs(p1, p2, AVAHI_DNS_FIELD_ANCOUNT))
    goto finish;

  if (!copy_rrs(p1, p2, AVAHI_DNS_FIELD_NSCOUNT))
    goto finish;

  if (!copy_rrs(p1, p2, AVAHI_DNS_FIELD_ARCOUNT))
    goto finish;

  host_name = avahi_get_host_name_strdup();

finish:
  if (p2)
    avahi_dns_packet_free(p2);
  if (p1)
    avahi_dns_packet_free(p1);
  if (host_name)
    free(host_name);

  return 0;
}
</code>

The code has the following build issues:
<error>
fuzz/fuzz-consume-record.c:1:2: error: unknown type name 'The'
 The fixed code is as follows:
 ^
fuzz/fuzz-consume-record.c:1:11: error: expected ';' after top level declarator
 The fixed code is as follows:
          ^
          ;
fuzz/fuzz-consume-record.c:3:10: fatal error: 'algorithm' file not found
#include <algorithm>
         ^~~~~~~~~~~
3 errors generated.

Fix failure
fuzz/fuzz-consume-record.cpp:1:2: error: unknown type name 'The'
 The fixed code is as follows:
 ^
fuzz/fuzz-consume-record.cpp:1:11: error: expected ';' after top level declarator
 The fixed code is as follows:
          ^
          ;
In file included from fuzz/fuzz-consume-record.cpp:4:
In file included from /usr/local/lib/clang/15.0.0/include/fuzzer/FuzzedDataProvider.h:27:
/usr/local/bin/../include/c++/v1/vector:725:9: error: use of undeclared identifier '__sanitizer_annotate_contiguous_container'; did you mean '__annotate_contiguous_container'?
        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);
        ^
/usr/local/bin/../include/c++/v1/vector:719:10: note: '__annotate_contiguous_container' declared here
    void __annotate_contiguous_container(const void *__beg, const void *__end,
         ^
3 errors generated.
</error>

Fix code:
1. Consider the possible solution for the issues listed above.
2. Apply the solutions to the original code.
It's important to show the complete code, not only the fixed line.
<solution>
