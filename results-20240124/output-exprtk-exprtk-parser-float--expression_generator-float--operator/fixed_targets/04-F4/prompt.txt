Given the following C++ program and its build error message, fix the code to achieve the original functionality.

If a function is missing, fix it by including the related libraries.

If the error contains "undefined reference to", this means one or more of the header <code>#include</code> directives need to be wrapped with <code>extern "C" {}</code> for the object linking to succeed. You must fix this by rewriting the relevant <code>#include</code> and wrapping it with <code>extern "C" {}</code>.

Below is the code needs to be built:
<code>
#include <cstdint>
#include <chrono>
#include <string>

#define exprtk_enable_range_runtime_checks
#include "exprtk.hpp"

struct timeout_rtc_handler : public exprtk::loop_runtime_check
{
   timeout_rtc_handler()
   : exprtk::loop_runtime_check()
   {}

   class timeout_exception : public std::runtime_error
   {
   public:
       timeout_exception(const std::string& what = "")
       : std::runtime_error(what)
       {}
   };

   static constexpr std::size_t max_iterations = 5000000;

   using time_point_t = std::chrono::time_point<std::chrono::steady_clock>;

   void set_timeout_time(const time_point_t& timeout_tp)
   {
      timeout_tp_ = timeout_tp;
   }

   bool check() override
   {
      if (++iterations_ >= max_iterations)
      {
         if (std::chrono::steady_clock::now() >= timeout_tp_)
         {
            return false;
         }
         iterations_ = 0;
      }

      return true;
   }

   void handle_runtime_violation(const violation_context& ctx) override
   {
      throw timeout_exception("ExprTk Loop run-time timeout violation.");
   }

   std::size_t iterations_ = 0;
   time_point_t timeout_tp_;
};

template <typename T>
void run(const std::string& expression_string)
{
   typedef exprtk::symbol_table<T>    symbol_table_t;
   typedef exprtk::expression<T>      expression_t;
   typedef exprtk::parser<T>          parser_t;
   typedef exprtk::loop_runtime_check loop_runtime_check_t;

   T x = T(1.2345);
   T y = T(2.2345);
   T z = T(3.2345);
   T w = T(4.2345);

   symbol_table_t symbol_table;
   symbol_table.add_variable("x",x);
   symbol_table.add_variable("y",y);
   symbol_table.add_variable("z",z);
   symbol_table.add_variable("w",w);
   symbol_table.add_constants();

   expression_t expression;
   expression.register_symbol_table(symbol_table);

   timeout_rtc_handler loop_runtime_check;
   loop_runtime_check.loop_set = loop_runtime_check_t::e_all_loops;
   loop_runtime_check.max_loop_iterations = 100000;

   parser_t parser;

   parser.register_loop_runtime_check(loop_runtime_check);

   if (parser.compile(expression_string, expression))
   {
      const std::size_t max_expression_size = 64 * 1024;

      if (expression_string.size() <= max_expression_size)
      {
         const auto max_duration = std::chrono::seconds(25);
         const auto timeout_tp = std::chrono::steady_clock::now() + max_duration;
         loop_runtime_check.set_timeout_time(timeout_tp);

         try
         {
            expression.value();
         }
         catch (std::runtime_error& rte)
         {}

         parser.clear_loop_runtime_check();
      }
   }
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
{
   const std::string expression(reinterpret_cast<const char*>(data), size);

   run<double>(expression);
   run<float> (expression);

   return 0;
}

extern "C" {
   template<>
   exprtk::details::expression_node<float> * exprtk::parser<float>::expression_generator<float>::operator()(exprtk::parser<float>::expression_generator *, int *, bool);
}
</code>

The code has the following build issues:
<error>
/src/exprtk_fuzzer.cpp:119:132: error: no type named 'expression_generator' in 'exprtk::parser<float>'; did you mean 'expression_node_ptr'?
   exprtk::details::expression_node<float> * exprtk::parser<float>::expression_generator<float>::operator()(exprtk::parser<float>::expression_generator *, int *, bool);
                                                                                                            ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~
                                                                                                                                   expression_node_ptr
./exprtk.hpp:19582:59: note: 'expression_node_ptr' declared here
      typedef expression_node_t*                          expression_node_ptr;
                                                          ^
/src/exprtk_fuzzer.cpp:119:98: error: template specialization requires 'template<>'
   exprtk::details::expression_node<float> * exprtk::parser<float>::expression_generator<float>::operator()(exprtk::parser<float>::expression_generator *, int *, bool);
                                                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~  ^
/src/exprtk_fuzzer.cpp:118:4: error: templates must have C++ linkage
   template<>
   ^~~~~~~~~~
/src/exprtk_fuzzer.cpp:117:1: note: extern "C" language linkage specification begins here
extern "C" {
^
3 errors generated.
</error>

Fix code:
1. Consider the possible solution for the issues listed above.
2. Apply the solutions to the original code.
It's important to show the complete code, not only the fixed line.
<solution>
