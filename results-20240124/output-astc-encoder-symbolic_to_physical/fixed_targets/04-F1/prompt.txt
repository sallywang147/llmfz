Given the following C++ program and its build error message, fix the code to achieve the original functionality.

If a function is missing, fix it by including the related libraries.

If the error contains "undefined reference to", this means one or more of the header <code>#include</code> directives need to be wrapped with <code>extern "C" {}</code> for the object linking to succeed. You must fix this by rewriting the relevant <code>#include</code> and wrapping it with <code>extern "C" {}</code>.

Below is the code needs to be built:
<code>
 #include "astcenc_internal.h"

#include <fuzzer/FuzzedDataProvider.h>
#include <array>
#include <vector>

struct BlockSizes
{
	int x;
	int y;
	int z;
};

std::array<BlockSizes, 3> testSz {{
	{ 4,  4, 1}, // Highest bitrate
	{12, 12, 1}, // Largest 2D block
	{6,  6,  6}  // Largest 3D block
}};

std::array<block_size_descriptor, 3> testBSD;

/**
 * @brief Utility function to create all of the block size descriptors needed.
 *
 * This is triggered once via a static initializer.
 *
 * Triggering once is important so that we only create a single BSD per block
 * size we need, rather than one per fuzzer iteration (it's expensive). This
 * improves fuzzer throughput by ~ 1000x!
 *
 * Triggering via a static initializer, rather than a lazy init in the fuzzer
 * function, is important because is means that the BSD is allocated before
 * fuzzing starts. This means that leaksanitizer will ignore the fact that we
 * "leak" the dynamic allocations inside the BSD (we never call term()).
 */
bool bsd_initializer()
{
	for (int i = 0; i < testSz.size(); i++)
	{
		init_block_size_descriptor(
		    testSz[i].x,
		    testSz[i].y,
		    testSz[i].z,
		    false,
		    4,
		    1.0f,
		    testBSD[i]);
	}

	return true;
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
{
	// Preinitialize the block size descriptors we need
	static bool init = bsd_initializer();

	// Must have 4 (select block size) and 16 (payload) bytes
	if (size < 4 + 16)
	{
		return 0;
	}

	FuzzedDataProvider stream(data, size);

	// Select a block size to test
	int i = stream.ConsumeIntegralInRange<int>(0, testSz.size() - 1);

	// Populate the symbolic block
	symbolic_compressed_block scb;
	std::vector<uint8_t> buffer = stream.ConsumeBytes<uint8_t>(16);
	std::memcpy(&scb, buffer.data(), 16);

	// Call the function under test
	physical_compressed_block pcb;
	symbolic_to_physical(testBSD[i], scb, pcb);

	return 0;
}
</code>

The code has the following build issues:
<error>
./Fuzzers/fuzz_astc_physical_to_symbolic.cpp:75:2: error: unknown type name 'physical_compressed_block'; did you mean 'symbolic_compressed_block'?
        physical_compressed_block pcb;
        ^~~~~~~~~~~~~~~~~~~~~~~~~
        symbolic_compressed_block
./astcenc_internal.h:1068:8: note: 'symbolic_compressed_block' declared here
struct symbolic_compressed_block
       ^
./Fuzzers/fuzz_astc_physical_to_symbolic.cpp:76:2: error: no matching function for call to 'symbolic_to_physical'
        symbolic_to_physical(testBSD[i], scb, pcb);
        ^~~~~~~~~~~~~~~~~~~~
./astcenc_internal.h:2150:6: note: candidate function not viable: no known conversion from 'symbolic_compressed_block' to 'uint8_t *' (aka 'unsigned char *') for 3rd argument
void symbolic_to_physical(
     ^
2 errors generated.
</error>

Fix code:
1. Consider the possible solution for the issues listed above.
2. Apply the solutions to the original code.
It's important to show the complete code, not only the fixed line.
<solution>
